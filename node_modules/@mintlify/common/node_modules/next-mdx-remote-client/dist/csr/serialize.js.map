{"version":3,"file":"serialize.js","sourceRoot":"","sources":["../../src/csr/serialize.ts"],"names":[],"mappings":"AAAA;;;GAGG;AAEH,OAAO,EAAE,cAAc,EAAE,MAAM,iBAAiB,CAAC;AAGjD,OAAO,EAAE,sBAAsB,EAAE,MAAM,gBAAgB,CAAC;AACxD,OAAO,EAAE,OAAO,EAAE,MAAM,mBAAmB,CAAC;AAC5C,OAAO,EAAE,OAAO,EAAE,MAAM,mBAAmB,CAAC;AAM5C;;;;;GAKG;AACH,MAAM,CAAC,KAAK,UAAU,SAAS,CAG7B,EACA,MAAM,EACN,OAAO,GAAG,EAAE,GACW;IACvB,MAAM,EACJ,UAAU,GAAG,EAAE,EACf,cAAc,EACd,cAAc,EACd,gBAAgB,EAChB,KAAK,GAAG,EAAY,EACpB,kBAAkB,GACnB,GAAG,OAAO,CAAC;IAEZ,MAAM,EAAE,KAAK,EAAE,WAAW,EAAE,GAAG,OAAO,CAAe,MAAM,EAAE,gBAAgB,CAAC,CAAC;IAE/E,MAAM,iBAAiB,GAAsB;QAC3C,GAAG,UAAU;QACb,oBAAoB,EAAE,GAAG,EAAE,sFAAsF;KAClH,CAAC;IAEF,IAAI,CAAC;QACH,MAAM,EAAE,cAAc,EAAE,GAAG,MAAM,OAAO,CAAC,KAAK,EAAE;YAC9C,UAAU,EAAE,iBAAiB;YAC7B,cAAc;YACd,cAAc;SACf,CAAC,CAAC;QAEH,IAAI,kBAAkB;YACpB,sBAAsB,CAAC,cAAc,CAAC,IAAI,EAAE,kBAAkB,EAAE,KAAK,CAAC,CAAC;QAEzE,OAAO;YACL,cAAc,EAAE,MAAM,CAAC,cAAc,CAAC;YACtC,WAAW;YACX,KAAK;SACN,CAAC;IACJ,CAAC;IAAC,OAAO,KAAc,EAAE,CAAC;QACxB,OAAO;YACL,KAAK,EAAE,cAAc,CAAC,KAAK,CAAU;YACrC,WAAW;YACX,KAAK;SACN,CAAC;IACJ,CAAC;AACH,CAAC","sourcesContent":["/**\n * Copyright (c) @talatkuyuk AKA @ipikuka\n * SPDX-License-Identifier: MPL-2.0\n */\n\nimport { serializeError } from \"serialize-error\";\n\nimport type { CompileMdxOptions } from \"../lib/types.js\";\nimport { passVfileDataIntoScope } from \"../lib/util.js\";\nimport { prepare } from \"../lib/prepare.js\";\nimport { compile } from \"../lib/compile.js\";\n\nimport type { SerializeResult, SerializeProps, SerializeOptions } from \"./types.js\";\n\nexport type { SerializeResult, SerializeProps, SerializeOptions };\n\n/**\n * compiles the MDX source.\n *\n * the compiled source can be passed into \"<MDXClient />\" or \"hydrate\" to be rendered on the client side (csr).\n *\n */\nexport async function serialize<\n  TFrontmatter extends Record<string, unknown> = Record<string, unknown>,\n  TScope extends Record<string, unknown> = Record<string, unknown>,\n>({\n  source,\n  options = {},\n}: SerializeProps<TScope>): Promise<SerializeResult<TFrontmatter, TScope>> {\n  const {\n    mdxOptions = {},\n    disableExports,\n    disableImports,\n    parseFrontmatter,\n    scope = {} as TScope,\n    vfileDataIntoScope,\n  } = options;\n\n  const { vfile, frontmatter } = prepare<TFrontmatter>(source, parseFrontmatter);\n\n  const compileMDXOptions: CompileMdxOptions = {\n    ...mdxOptions,\n    providerImportSource: \"#\", // important! doesn't matter \"@mdx-js/react\" since the outputFormat is \"function-body\"\n  };\n\n  try {\n    const { compiledSource } = await compile(vfile, {\n      mdxOptions: compileMDXOptions,\n      disableExports,\n      disableImports,\n    });\n\n    if (vfileDataIntoScope)\n      passVfileDataIntoScope(compiledSource.data, vfileDataIntoScope, scope);\n\n    return {\n      compiledSource: String(compiledSource),\n      frontmatter,\n      scope,\n    };\n  } catch (error: unknown) {\n    return {\n      error: serializeError(error) as Error,\n      frontmatter,\n      scope,\n    };\n  }\n}\n"]}