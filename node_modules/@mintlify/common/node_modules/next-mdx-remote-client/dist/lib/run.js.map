{"version":3,"file":"run.js","sourceRoot":"","sources":["../../src/lib/run.ts"],"names":[],"mappings":"AAAA;;;GAGG;AAEH,OAAO,KAAK,KAAK,MAAM,OAAO,CAAC;AAC/B,OAAO,KAAK,UAAU,MAAM,mBAAmB,CAAC;AAChD,OAAO,KAAK,aAAa,MAAM,uBAAuB,CAAC;AAiBvD,wDAAwD;AAExD;;;;;GAKG;AACH,SAAS,mBAAmB,CAAC,OAAmB;IAC9C,MAAM,iBAAiB,GAAG;QACxB,aAAa,EAAE;YACb,gBAAgB,EAAE,OAAO,CAAC,UAAU,EAAE,gBAAgB;YACtD,OAAO,EAAE,OAAO,CAAC,UAAU,EAAE,OAAO;YACpC,GAAG,EAAG,UAAyB,CAAC,GAAG;YACnC,IAAI,EAAG,UAAyB,CAAC,IAAI;YACrC,MAAM,EAAG,aAA+B,CAAC,MAAM;YAC/C,QAAQ,EAAG,UAAyB,CAAC,QAAQ,EAAE,iBAAiB;YAChE,KAAK;SACN;QACD,WAAW,EAAE,OAAO,CAAC,WAAW;QAChC,GAAG,OAAO,CAAC,KAAK;KACjB,CAAC;IAEF,OAAO;QACL,IAAI,EAAE,MAAM,CAAC,IAAI,CAAC,iBAAiB,CAAC;QACpC,MAAM,EAAE,MAAM,CAAC,MAAM,CAAC,iBAAiB,CAAC;KACzC,CAAC;AACJ,CAAC;AAED;;GAEG;AACH,MAAM,UAAU,OAAO,CAAC,cAAsB,EAAE,OAAmB;IACjE,MAAM,EAAE,IAAI,EAAE,MAAM,EAAE,GAAG,mBAAmB,CAAC,OAAO,CAAC,CAAC;IAEtD,oBAAoB;IACpB,MAAM,YAAY,GAAG,cAAa,CAAC,CAAC,WAAW,CAAC;IAEhD,mFAAmF;IACnF,MAAM,SAAS,GAAwB,OAAO,CAAC,SAAS,CACtD,YAAY,EACZ,IAAI,CAAC,MAAM,CAAC,cAAc,CAAC,CAC5B,CAAC;IAEF,MAAM,EAAE,OAAO,EAAE,OAAO,EAAE,GAAG,GAAG,EAAE,GAAG,SAAS,CAAC,GAAG,MAAM,CAAc,CAAC;IAEvE,OAAO,EAAE,OAAO,EAAE,GAAG,EAAE,CAAC;AAC1B,CAAC;AAED;;GAEG;AACH,MAAM,CAAC,KAAK,UAAU,QAAQ,CAC5B,cAAsB,EACtB,OAAmB;IAEnB,MAAM,EAAE,IAAI,EAAE,MAAM,EAAE,GAAG,mBAAmB,CAAC,OAAO,CAAC,CAAC;IAEtD,oBAAoB;IACpB,MAAM,aAAa,GAAG,KAAK,eAAc,CAAC,CAAC,WAAW,CAAC;IAEvD,4DAA4D;IAE5D,yFAAyF;IACzF,MAAM,SAAS,GAAyB,OAAO,CAAC,SAAS,CACvD,aAAa,EACb,IAAI,CAAC,MAAM,CAAC,cAAc,CAAC,CAC5B,CAAC;IAEF,MAAM,EAAE,OAAO,EAAE,OAAO,EAAE,GAAG,GAAG,EAAE,GAAG,MAAO,SAAS,CAAC,GAAG,MAAM,CAAwB,CAAC;IAExF,OAAO,EAAE,OAAO,EAAE,GAAG,EAAE,CAAC;AAC1B,CAAC","sourcesContent":["/**\n * Copyright (c) @talatkuyuk AKA @ipikuka\n * SPDX-License-Identifier: MPL-2.0\n */\n\nimport * as React from \"react\";\nimport * as jsxRuntime from \"react/jsx-runtime\";\nimport * as jsxDevRuntime from \"react/jsx-dev-runtime\";\nimport type { MDXModule } from \"mdx/types\";\nimport type { Fragment, Jsx, JsxDev } from \"@mdx-js/mdx\";\n\nimport type { RunOptions, RunResult } from \"./types.js\";\n\ntype JsxRuntime = {\n  Fragment: Fragment;\n  jsx: Jsx;\n  jsxs: Jsx;\n};\n\ntype JsxDevRuntime = {\n  Fragment: Fragment;\n  jsxDEV: JsxDev;\n};\n\n// TODO: use run and runSync function from \"@mdx-js/mdx\"\n\n/**\n * creates an object to be used for the function construction\n *\n * @param options RunOptions\n * @returns keys and values of the object\n */\nfunction prepareConstruction(options: RunOptions) {\n  const constructionScope = {\n    runMdxOptions: {\n      useMDXComponents: options.mdxOptions?.useMDXComponents,\n      baseUrl: options.mdxOptions?.baseUrl,\n      jsx: (jsxRuntime as JsxRuntime).jsx,\n      jsxs: (jsxRuntime as JsxRuntime).jsxs,\n      jsxDEV: (jsxDevRuntime as JsxDevRuntime).jsxDEV,\n      Fragment: (jsxRuntime as JsxRuntime).Fragment, // doesn't matter\n      React,\n    },\n    frontmatter: options.frontmatter,\n    ...options.scope,\n  };\n\n  return {\n    keys: Object.keys(constructionScope),\n    values: Object.values(constructionScope),\n  };\n}\n\n/**\n * parses and runs the javascript code syncronously in the compiled MDX source.\n */\nexport function runSync(compiledSource: string, options: RunOptions): RunResult {\n  const { keys, values } = prepareConstruction(options);\n\n  /* v8 ignore next */\n  const SyncFunction = function () {}.constructor;\n\n  // constructs the compiled source utilizing Reflect API with \"function constructor\"\n  const hydrateFn: typeof SyncFunction = Reflect.construct(\n    SyncFunction,\n    keys.concat(compiledSource),\n  );\n\n  const { default: Content, ...mod } = hydrateFn(...values) as MDXModule;\n\n  return { Content, mod };\n}\n\n/**\n * parses and runs the javascript code asyncronously in the compiled MDX source.\n */\nexport async function runAsync(\n  compiledSource: string,\n  options: RunOptions,\n): Promise<RunResult> {\n  const { keys, values } = prepareConstruction(options);\n\n  /* v8 ignore next */\n  const AsyncFunction = async function () {}.constructor;\n\n  // await new Promise((resolve) => setTimeout(resolve, 500));\n\n  // constructs the compiled source utilizing Reflect API with \"async function constructor\"\n  const hydrateFn: typeof AsyncFunction = Reflect.construct(\n    AsyncFunction,\n    keys.concat(compiledSource),\n  );\n\n  const { default: Content, ...mod } = await (hydrateFn(...values) as Promise<MDXModule>);\n\n  return { Content, mod };\n}\n"]}